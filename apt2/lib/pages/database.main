[09:11, 20/02/2025] Fredi VODOUNOUKPE**Dev mobile and  web  *( Apple center)*: import 'package:flutter/material.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'package:intl/intl.dart'; // ğŸ“Œ Pour formater la date et l'heure

void main() async {
  WidgetsFlutterBinding.ensureInitialized(); // ğŸ”¹ Permet d'utiliser SQLite avant le dÃ©marrage de l'app
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      home: TransactionHistoryScreen(), // ğŸ”¹ Ã‰cran principal
    );
  }
}

// ğŸ“Œ 1ï¸âƒ£ Classe pour gÃ©rer SQLite
class DatabaseHelper {
  static Database? _database;

  // ğŸ”¹ RÃ©cupÃ©rer la base de donnÃ©es
  Future<Database> get database async {
    if (_database != null) return _databaâ€¦
[09:16, 20/02/2025] Fredi VODOUNOUKPE**Dev mobile and  web  *( Apple center)*: import 'package:flutter/material.dart';
import 'package:sqflite/sqflite.dart';
import 'package:path/path.dart';
import 'package:intl/intl.dart'; // ğŸ“Œ Pour formater la date et l'heure

void main() async {
  WidgetsFlutterBinding.ensureInitialized(); // ğŸ”¹ Permet d'utiliser SQLite avant le dÃ©marrage de l'app
  runApp(MyApp());
}

class MyApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      debugShowCheckedModeBanner: false,
      home: TransactionHistoryScreen(), // ğŸ”¹ Ã‰cran principal
    );
  }
}

// ğŸ“Œ 1ï¸âƒ£ Classe pour gÃ©rer SQLite
class DatabaseHelper {
  static Database? _database;

  // ğŸ”¹ RÃ©cupÃ©rer la base de donnÃ©es
  Future<Database> get database async {
    if (_database != null) return _database!;
    _database = await _initDB();
    return _database!;
  }

  // ğŸ”¹ Initialiser la base de donnÃ©es
  Future<Database> _initDB() async {
    String path = join(await getDatabasesPath(), 'transactions.db'); // ğŸ“Œ DÃ©finition du chemin du fichier SQLite
    return await openDatabase(
      path,
      version: 1,
      onCreate: (db, version) { // ğŸ”¹ CrÃ©ation de la table SQLite
        return db.execute(
          """
          CREATE TABLE transactions(
            id INTEGER PRIMARY KEY AUTOINCREMENT, 
            amount INTEGER,
            recipient TEXT,
            date TEXT
          )
          """,
        );
      },
    );
  }

  // ğŸ”¹ Ajouter une transaction
  Future<void> insertTransaction(int amount, String recipient) async {
    final db = await database;
    String currentDate = DateFormat('yyyy-MM-dd HH:mm:ss').format(DateTime.now()); // ğŸ“Œ GÃ©nÃ¨re la date et l'heure actuelles
    await db.insert("transactions", {
      "amount": amount,
      "recipient": recipient,
      "date": currentDate,
    });
  }

  // ğŸ”¹ RÃ©cupÃ©rer toutes les transactions
  Future<List<Map<String, dynamic>>> getTransactions() async {
    final db = await database;
    return await db.query("transactions", orderBy: "date DESC"); // ğŸ“Œ Trie par date (la plus rÃ©cente en premier)
  }

  // ğŸ”¹ Supprimer une transaction
  Future<void> deleteTransaction(int id) async {
    final db = await database;
    await db.delete("transactions", where: "id = ?", whereArgs: [id]);
  }
}

// ğŸ“Œ 2ï¸âƒ£ Interface Utilisateur
class TransactionHistoryScreen extends StatefulWidget {
  @override
  _TransactionHistoryScreenState createState() =>
      _TransactionHistoryScreenState();
}

class _TransactionHistoryScreenState extends State<TransactionHistoryScreen> {
  final DatabaseHelper dbHelper = DatabaseHelper(); // ğŸ“Œ Instance de la base de donnÃ©es
  List<Map<String, dynamic>> transactions = []; // ğŸ”¹ Liste des transactions
  Map<String, dynamic>? selectedTransaction; // ğŸ”¹ Transaction sÃ©lectionnÃ©e

  @override
  void initState() {
    super.initState();
    _loadTransactions(); // ğŸ”¹ Charge les transactions au dÃ©marrage
  }

  // ğŸ”¹ Charger les transactions depuis SQLite
  Future<void> _loadTransactions() async {
    List<Map<String, dynamic>> loadedTransactions = await dbHelper.getTransactions();
    setState(() {
      transactions = loadedTransactions;
    });
  }

  // ğŸ”¹ Ajouter une transaction
  Future<void> _addTransaction(int amount, String recipient) async {
    await dbHelper.insertTransaction(amount, recipient);
    _loadTransactions(); // ğŸ”¹ RafraÃ®chir l'affichage
  }

  // ğŸ”¹ Supprimer une transaction
  Future<void> _removeTransaction(int id) async {
    await dbHelper.deleteTransaction(id);
    setState(() {
      selectedTransaction = null;
    });
    _loadTransactions();
  }
